# Copyright Red Hat
#
# virt_tests/testvm.py - Snapshot Manager test VM infrastructure.
#
# This file is part of the snapm project.
#
# SPDX-License-Identifier: Apache-2.0
"""
VM Setup Module for snapm End-to-End Testing
Handles creation of LVM2-based test VMs with proper storage layout for snapm
"""
import os
import re
import subprocess
import time
import shutil
import shlex
from pathlib import Path
from typing import Optional

from .util import log_print, err_print

TEST_IMAGE_DIR = "/var/lib/libvirt/images"
TEST_IMAGE_SIZE = 20  # GiB

SSH_KEY_PATH = "/root/.ssh/id_ed25519-snapm-test"

try:
    VM_INSTALL_TIMEOUT = int(os.getenv("VM_INSTALL_TIMEOUT", 3600))  # seconds
except (TypeError, ValueError):
    VM_INSTALL_TIMEOUT = 3600
    err_print(f"Invalid VM_INSTALL_TIMEOUT: {os.getenv('VM_INSTALL_TIMEOUT', None)}")
    err_print(f"Using default ({VM_INSTALL_TIMEOUT}s)")


def _need_force_bios() -> bool:
    """
    Does the platform require forced firmware=bios workaround?
    """
    try:
        with open("/etc/os-release", "r", encoding="utf8") as osr:
            for line in osr.read().splitlines():
                if line.strip() == "ID=ubuntu":
                    log_print("üîß Enabling firmware=bios workaround.")
                    return True
    except OSError:
        pass
    return False


_QEMU_FORCE_BIOS = _need_force_bios()


def ensure_ssh_key(key_path: str = SSH_KEY_PATH) -> str:
    """Generate SSH key if it doesn't exist"""
    ssh_dir = os.path.dirname(key_path)
    os.makedirs(ssh_dir, mode=0o700, exist_ok=True)

    try:
        os.chmod(ssh_dir, 0o700)
    except OSError as err:
        err_print(f"Failed to set ~/.ssh permissions! ({err})")
        # Best-effort; proceed if chmod fails (e.g., on unusual FS)

    if not os.path.exists(key_path):
        subprocess.run(
            [
                "ssh-keygen",
                "-t",
                "ed25519",
                "-f",
                key_path,
                "-N",
                "",
                "-C",
                "snapm-test-automation",
            ],
            check=True,
        )
        log_print(f"üîë Generated SSH key: {key_path}")
        # Enforce sane permissions
        os.chmod(key_path, 0o600)

    # Get public key content for injection
    pub_key_path = f"{key_path}.pub"
    if not os.path.exists(pub_key_path):
        raise FileNotFoundError(f"Public key file not found: {pub_key_path}")
    with open(pub_key_path, "r", encoding="utf8") as f:
        return f.read().strip()


ROOT_ENABLED = """# Root password (for testing only)
rootpw --plaintext redhat

# User account for testing
user --name=testuser --password=redhat --plaintext --groups=wheel"""

ROOT_DISABLED = """# Root account locked
rootpw --lock
"""

PERMIT_ROOT_PW = """# Configure SSH for testing
echo "PermitRootLogin yes" >> /etc/ssh/sshd_config
echo "PasswordAuthentication yes" >> /etc/ssh/sshd_config"""

FORBID_ROOT_PW = """# Disable passwords for SSH
echo "PermitRootLogin prohibit-password" >> /etc/ssh/sshd_config"""

BOOT_LAYOUTS = {
    "bios": """# Disk partitioning information
part /boot --fstype="xfs" --ondisk=vda --size=1024
part biosboot --fstype="biosboot" --ondisk=vda --size=1
""",
    "uefi": """# Disk partitioning information
part /boot --fstype="xfs" --ondisk=vda --size=1024
part /boot/efi --fstype="efi" --ondisk=vda --size=600 --fsoptions="umask=0077,shortname=winnt"
""",
}

STORAGE_LAYOUTS = {
    "lvm": """# Generated by virt_tests
ignoredisk --only-use=vda
# Partition clearing information
clearpart --all --initlabel
{boot_layout}
# LVM2 linear layout
part pv.48 --fstype="lvmpv" --ondisk=vda --grow
volgroup {vg_name} --pesize=4096 pv.48
logvol / --fstype="xfs" --size=8192 --name=root --vgname={vg_name}
logvol /var --fstype="xfs" --size=4096 --name=var --vgname={vg_name}""",
    "lvm-thin": """# Generated by virt_tests
ignoredisk --only-use=vda
# Partition clearing information
clearpart --all --initlabel
{boot_layout}
# LVM2 thin layout
part pv.48 --fstype="lvmpv" --ondisk=vda --grow
volgroup {vg_name} --pesize=4096 pv.48
logvol none --size=16000 --grow --thinpool --metadatasize=12 --chunksize=64 --name=pool00 --vgname={vg_name}
logvol /var --fstype="xfs" --size=4096 --thin --poolname=pool00 --name=var --vgname={vg_name}
logvol / --fstype="xfs" --size=8192 --thin --poolname=pool00 --name=root --vgname={vg_name}""",
}


class SnapmTestVM:
    """Manages test VMs for snapm testing with LVM2 storage"""

    def __init__(
        self,
        name: str,
        base_os: str = "fedora42",
        storage: str = "lvm",
        uefi: bool = False,
        allow_root: bool = False,
        repo: str = "snapshotmanager/snapm",
        ref_name: str = "main",
    ):
        self.name: str = name
        self.base_os: str = base_os
        self.storage: str = storage
        self.vm_disk_size: int = TEST_IMAGE_SIZE
        self.vm_memory: int = 4096
        self.vm_vcpus: int = 2
        self.vm_uefi: bool = uefi
        self.allow_root = allow_root
        self.repo: str = repo
        self.ref_name: str = ref_name
        self.test_dir: Path = Path(f"/tmp/{name}")
        self.test_dir.mkdir(exist_ok=True)

        # Basic input validation to avoid shell injection in remote commands
        if not re.fullmatch(r"[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+", self.repo):
            raise ValueError(f"Invalid GitHub repo slug: {self.repo!r}")
        if not re.fullmatch(r"[A-Za-z0-9._/\-]+", self.ref_name):
            raise ValueError(f"Invalid ref name: {self.ref_name!r}")

        # Set by IP discovery in wait_for_ssh()
        self.ip_address: Optional[str] = None

    def create_kickstart_config(self) -> str:
        """Generate kickstart file for LVM2-based installation"""

        ssh_public_key = ensure_ssh_key()

        # Base kickstart template for LVM2 with multiple volumes
        kickstart_template = f"""# {self.base_os} kickstart configuration for snapm testing
# Automated installation with {self.storage} storage layout and
# {"uefi" if self.vm_uefi else "bios"} firmware.

# Shutdown after installation
shutdown

# System language and keyboard
lang en_US.UTF-8
keyboard us

{ROOT_ENABLED if self.allow_root else ROOT_DISABLED}

# System timezone
timezone UTC --utc

# Firewall configuration
firewall --disabled

{STORAGE_LAYOUTS[self.storage]}

bootloader

# Package selection
%packages --ignoremissing
@core
qemu-guest-agent
lvm2
git
python3
python3-pip
openssh-server
python3-dateutil
python3-dbus-client-gen
python3-dbus-python-client-gen
python3-justbytes
python3-psutil
python3-pytest
python3-wcwidth
# Note: snapm and boom will be installed post-installation
%end

# Enable services
services --enabled=sshd,NetworkManager,qemu-guest-agent

# Post-installation script
%post --log=/var/log/kickstart-post.log

{PERMIT_ROOT_PW if self.allow_root else FORBID_ROOT_PW}

# Force enable NetworkManager (centos-stream9)
systemctl enable --now NetworkManager

# Enable serial console
systemctl enable serial-getty@ttyS0.service

# Create marker file to indicate successful installation
touch /root/kickstart-complete

# Install test SSH key
install -d -m 0700 /root/.ssh
cat > /root/.ssh/authorized_keys <<'EOF'
{ssh_public_key}
EOF
chmod 0600 /root/.ssh/authorized_keys
restorecon -R /root/.ssh || true

%end
"""

        # Determine distro-specific values
        if self.base_os.startswith("fedora"):
            vg_name = "fedora"
        elif self.base_os.startswith("centos"):
            vg_name = "cs"  # CentOS Stream default
        else:  # RHEL
            vg_name = "rhel"

        boot_layout = BOOT_LAYOUTS["uefi" if self.vm_uefi else "bios"]

        kickstart_content = kickstart_template.format(
            vg_name=vg_name,
            boot_layout=boot_layout,
        )

        kickstart_path = self.test_dir / "kickstart.cfg"
        with open(kickstart_path, "w", encoding="utf8") as f:
            f.write(kickstart_content)

        return str(kickstart_path)

    def create_vm(self) -> bool:
        """Create and install the test VM using virt-install"""

        kickstart_path = self.create_kickstart_config()

        # VM disk image
        os.makedirs(TEST_IMAGE_DIR, exist_ok=True)
        disk_path = f"{TEST_IMAGE_DIR}/{self.name}.qcow2"

        boot_firmware = f"uefi={'on' if self.vm_uefi else 'off'}"
        if _QEMU_FORCE_BIOS and not self.vm_uefi:
            boot_firmware = "firmware=bios"

        ks_opts = "inst.cmdline inst.ksstrict"
        console = "console=tty0 console=ttyS0"

        virt_install_cmd = [
            "unbuffer",
            "virt-install",
            "--boot",
            boot_firmware,
            "--name",
            self.name,
            "--memory",
            str(self.vm_memory),
            "--vcpus",
            str(self.vm_vcpus),
            "--check",
            "disk_size=off",
            "--disk",
            f"path={disk_path},size={self.vm_disk_size},format=qcow2,bus=virtio",
            "--install",
            self.base_os,
            "--initrd-inject",
            kickstart_path,
            "--extra-args",
            f"inst.ks=file:/{os.path.basename(kickstart_path)} {ks_opts} {console}",
            "--network",
            "network=default",
            "--graphics",
            "none",
            "--serial",
            "pty",
            "--console",
            "pty,target_type=serial",
            "--wait",
            "-1",  # Wait for installation to complete
            "--noreboot",  # Don't reboot automatically
        ]

        # Selectively override machine type
        if _QEMU_FORCE_BIOS and not self.vm_uefi:
            virt_install_cmd += ["--machine", "pc-q35-7.2"]

        log_print(f"üèÅ Creating VM {self.name} with command:")
        log_print(" ".join(virt_install_cmd))

        try:
            result = subprocess.run(virt_install_cmd, timeout=VM_INSTALL_TIMEOUT)

            if result.returncode != 0:
                err_print(
                    f"üî• VM creation failed (rc={result.returncode}): see virt-install output above"
                )
                return False

            log_print(f"üéØ VM {self.name} created successfully")
            return True
        except FileNotFoundError as e:
            if e.filename == "unbuffer":
                err_print("‚ÅâÔ∏è  `unbuffer` not found. Please install `expect`.")
            else:
                err_print(f"‚ÅâÔ∏è  Executable not found: {e.filename}")
            return False
        except subprocess.TimeoutExpired:
            err_print(f"‚è∞ VM creation timed out for {self.name} after {VM_INSTALL_TIMEOUT}s")
            return False
        except Exception as e:
            err_print(f"‚ÅâÔ∏è  Error creating VM: {e}")
            return False

    def start_vm(self) -> bool:
        """Start the VM"""
        log_print(f"üöÄ Starting VM: {self.name}")
        try:
            subprocess.run(
                ["virsh", "start", self.name], check=True, capture_output=False
            )
            log_print(f"üéØ VM {self.name} started")
            return True
        except subprocess.CalledProcessError as e:
            err_print(f"üî• Failed to start VM: {e}")
            return False

    def _execute_ssh_command(
        self, command: str, timeout: int = 60, capture_output: bool = False
    ):
        """Internal method to execute SSH commands with common options."""
        if not self.ip_address:
            raise ValueError(
                "SnapmTestVM: self.ip_address unset. Has wait_for_ssh() run?"
            )

        # fmt: off
        ssh_cmd = [
            "ssh",
            "-i", SSH_KEY_PATH,
            "-o", "UserKnownHostsFile=/dev/null",
            "-o", "BatchMode=yes",
            "-o", "LogLevel=ERROR",
            "-o", "StrictHostKeyChecking=no",
            "-o", "IdentitiesOnly=yes",
            "-o", "ConnectTimeout=5",
            f"root@{self.ip_address}",
            command,
        ]
        # fmt: on

        return subprocess.run(
            ssh_cmd,
            capture_output=capture_output,
            text=True,
            timeout=timeout,
        )

    def run_command(self, command: str, timeout: int = 60, check: bool = True) -> bool:
        """Execute command on the VM via SSH"""
        try:
            result = self._execute_ssh_command(command, timeout, capture_output=False)
            if check and result.returncode != 0:
                err_print(f"‚õî Command failed (rc={result.returncode}): {command}")
                return False
            return True
        except subprocess.TimeoutExpired:
            err_print(f"‚è∞ Command timed out: {command} after {timeout}s")
            return False
        except Exception as e:
            err_print(f"‚ÅâÔ∏è  Error executing command: {e}")
            return False

    def get_command_output(self, command: str, timeout: int = 60) -> Optional[str]:
        """Execute command and return output"""
        try:
            result = self._execute_ssh_command(command, timeout, capture_output=True)
            if result.returncode == 0:
                return result.stdout.strip()
            else:
                err_print(f"‚õî Command failed: {command} {result.stderr}")
                return None
        except subprocess.TimeoutExpired:
            err_print(f"‚è∞ Command timed out: {command}")
            return None
        except Exception as e:
            err_print(f"‚ÅâÔ∏è  Error getting command output: {e}")
            return None

    def wait_for_ssh(self, timeout: int = 300) -> bool:
        """Wait for SSH to become available"""

        log_print(f"üîç Determining VM IP address: {self.name}")
        # Get VM IP address
        start_time = time.time()
        vm_ip = None

        while time.time() - start_time < timeout:
            # Try 'virsh domifaddr' first
            try:
                result = subprocess.run(
                    ["virsh", "domifaddr", self.name],
                    capture_output=True,
                    text=True,
                    check=True,
                )

                # Parse IP from output
                lines = result.stdout.split("\n")
                for line in lines:
                    if "ipv4" in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            vm_ip = parts[3].split("/")[0]
                            break

                if vm_ip:
                    break
            except subprocess.CalledProcessError:
                pass
            # Fallback: try DHCP leases on default network
            try:
                leases = subprocess.run(
                    ["virsh", "net-dhcp-leases", "default"],
                    capture_output=True,
                    text=True,
                    check=True,
                )
                for line in leases.stdout.splitlines():
                    if "ipv4" in line and self.name in line:
                        parts = line.split()
                        for tok in parts:
                            if tok.count(".") == 3 and "/" in tok:
                                vm_ip = tok.split("/")[0]
                                break
                        if vm_ip:
                            break
                if vm_ip:
                    break
            except subprocess.CalledProcessError:
                pass
            time.sleep(5)

        if not vm_ip:
            err_print("üö® Could not determine VM IP address")
            return False

        log_print(f"‚òëÔ∏è  Found IP address: {vm_ip}")
        log_print(f"‚è±Ô∏è Waiting for SSH ({timeout}s): {self.name}")

        self.ip_address = vm_ip

        # Test SSH connectivity
        while time.time() - start_time < timeout:
            command = "echo ready"
            try:
                result = self._execute_ssh_command(command, 10, capture_output=True)
                if result.returncode == 0:
                    log_print(f"SSH ready on {self.ip_address}")
                    return True

            except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
                pass

            time.sleep(10)

        # Discovered IP address unusable?
        self.ip_address = None
        err_print("‚è∞ SSH connection timeout")
        return False

    def install_snapm_and_boom(self) -> bool:
        """Install snapm and boom-boot manager"""

        log_print(
            f"üíæ Installing snapm and boom-boot from git (repo: {self.repo} ref_name: {self.ref_name})"
        )

        safe_repo = shlex.quote(self.repo)
        safe_ref = shlex.quote(self.ref_name)

        commands = [
            # Install boom first (required by snapm)
            "git clone --depth=1 https://github.com/snapshotmanager/boom-boot.git /tmp/boom-boot",
            "cd /tmp/boom-boot && pip install -v .",
            # Install snapm
            f"git clone --depth=1 https://github.com/{safe_repo}.git -b {safe_ref} /tmp/snapm",
            "cd /tmp/snapm && pip install -v . ",
            "cd /tmp/snapm && cp -r etc/snapm /etc && cp systemd/* /usr/lib/systemd/system",
            # Notify systemd
            "systemctl daemon-reload",
            # Verify installation
            "snapm --version",
        ]

        for cmd in commands:
            if not self.run_command(cmd):
                err_print(f"Failed to execute: {cmd}")
                return False

        log_print("‚òëÔ∏è  snapm and boom installed successfully")
        return True

    def verify_lvm_setup(self) -> bool:
        """Verify that LVM2 is properly configured for snapm"""

        # Check volume groups
        vgs_output = self.get_command_output("vgs --noheadings -o vg_name")
        if not vgs_output:
            err_print("No volume groups found")
            return False

        # Check logical volumes
        lvs_output = self.get_command_output("lvs --noheadings -o lv_name,vg_name")
        if not lvs_output:
            err_print("No logical volumes found")
            return False

        log_print("LVM2 setup verification:")
        log_print(f"Volume groups: {vgs_output}")
        log_print(f"Logical volumes:\n{lvs_output}")

        # Verify required LVs exist (root, var at minimum)
        required_lvs = ["root", "var"]
        existing_lvs = [
            line.split()[0] for line in lvs_output.split("\n") if line.strip()
        ]

        for lv in required_lvs:
            if lv not in existing_lvs:
                err_print(f"Required logical volume '{lv}' not found")
                return False

        return True

    def cleanup(self):
        """Clean up VM and associated resources"""
        try:
            # Stop VM if running
            subprocess.run(["virsh", "destroy", self.name], capture_output=True)

            destroy_cmd = ["virsh", "undefine", self.name, "--remove-all-storage"]
            if self.vm_uefi:
                destroy_cmd.append("--nvram")
            subprocess.run(
                destroy_cmd,
                capture_output=True,
            )

            log_print(f"VM {self.name} cleaned up")

        except Exception as e:
            err_print(f"Error during cleanup: {e}")

        try:
            shutil.rmtree(self.test_dir)
        except Exception as e:
            err_print(f"Error cleaning up {self.test_dir}: {e}")

        # remove any orphaned qcow2 in default image dir
        try:
            disk_path = f"{TEST_IMAGE_DIR}/{self.name}.qcow2"
            if os.path.exists(disk_path):
                os.remove(disk_path)
        except Exception as e:
            err_print(f"Error removing disk image: {e}")


def setup_test_vm(
    name: str,
    base_os: str = "fedora42",
    storage: str = "lvm",
    uefi: bool = False,
    allow_root: bool = False,
    keep: bool = False,
    repo: str = "snapshotmanager/snapm",
    ref_name: str = "main",
) -> Optional[SnapmTestVM]:
    """
    Main function to set up a test VM for snapm testing

    Args:
        name: Name for the test VM
        base_os: Base operating system (fedora-40, centos-stream-9, etc.)

    Returns:
        Configured SnapmTestVM instance or None if setup failed
    """

    log_print(
        f"Setting up test VM: {name} (storage={storage}, uefi={uefi}, base_os={base_os})"
    )
    log_print(f"Target Git branch: https://github.com/{repo} {ref_name}")

    vm = SnapmTestVM(
        name,
        base_os,
        storage=storage,
        uefi=uefi,
        allow_root=allow_root,
        repo=repo,
        ref_name=ref_name,
    )

    # Step 1: Create and install VM
    if not vm.create_vm():
        err_print("Failed to create VM")
        return None

    # Step 2: Start VM
    if not vm.start_vm():
        err_print("Failed to start VM")
        if not keep:
            vm.cleanup()
        return None

    # Step 3: Wait for SSH
    if not vm.wait_for_ssh():
        err_print("SSH connectivity failed")
        if not keep:
            vm.cleanup()
        return None

    # Step 4: Verify LVM setup
    if not vm.verify_lvm_setup():
        err_print("LVM setup verification failed")
        if not keep:
            vm.cleanup()
        return None

    # Step 5: Install snapm and boom
    if not vm.install_snapm_and_boom():
        err_print("snapm/boom installation failed")
        if not keep:
            vm.cleanup()
        return None

    log_print(f"Test VM {name} setup complete!")
    log_print(f"SSH access: ssh root@{vm.ip_address}")

    return vm
